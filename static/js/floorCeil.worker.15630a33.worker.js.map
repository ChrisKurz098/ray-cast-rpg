{"version":3,"file":"static/js/floorCeil.worker.15630a33.worker.js","mappings":"AAEAA,UAAY,SAAyBC,GAEjC,IAAI,OAACC,EAAM,OAAEC,EAAM,OAAEC,EAAM,SAAEC,EAAQ,UAACC,EAAS,SAAEC,EAAQ,EAAGC,EAAC,EAAEC,GAAMR,EAAES,KAEvEP,EAAOQ,SAASV,IAEZ,GAAIA,EAAEW,OACF,OAAO,EACJ,CAEH,MAAMC,EA2ClB,SAAoBA,EAAUC,EAAOC,GACjC,MAAMC,EAAOF,EAAQC,EACrB,OAAOF,EAAWI,KAAKC,IAAIF,GA7CFG,CAAWlB,EAAEY,SAAUZ,EAAEa,MAAOZ,EAAOY,OAClDM,EAAaH,KAAKI,MAAOd,EAAWM,EAAYX,EAAOoB,UACvDC,EAAOtB,EAAEuB,GACTC,EAAOR,KAAKI,MAAMb,EAAI,EAAIY,EAAa,GAGvCM,EAAOT,KAAKU,IAAK1B,EAAEa,MAAQZ,EAAOY,OAGxC,IAAK,IAAIc,EAFIH,EAAOL,EAECQ,GAAOpB,EAAGoB,IAAO,CAClC,MAAMC,EAAID,EAAMpB,EAAI,EAEdsB,EADO5B,EAAQ,EAAI2B,EAAI3B,EAAOoB,SACjBL,KAAKC,IAAIQ,GAC5B,IAAIK,EAAK7B,EAAO6B,EAAId,KAAKC,IAAIjB,EAAEa,OAASgB,EACpCE,EAAK9B,EAAO8B,EAAIf,KAAKgB,IAAIhC,EAAEa,OAASgB,EACxCC,GAASxB,EAAW,EACpByB,GAASzB,EAAW,EAGpB,IAAI2B,EAA4B,GAApB,EAAQzB,EAAIc,GACxB,MAAMY,EAAwB,GAAV,GAAN,EAAWH,GAEnBI,EAAQN,EAAK,EAEnB1B,EAAOM,KAAKwB,GAAO7B,EAAS8B,GAAKC,EACjChC,EAAOM,KAAKwB,EAAM,GAAK7B,EAAS8B,EAAM,GAAGC,EACzChC,EAAOM,KAAKwB,EAAM,GAAK7B,EAAS8B,EAAM,GAAGC,EACzChC,EAAOM,KAAKwB,EAAM,GAAK,IAEvBA,EAAgC,IAAvB1B,EAAIoB,GAAOnB,EAAIc,GACxBnB,EAAOM,KAAKwB,GAAO5B,EAAU6B,GAAKC,EAAM,GACxChC,EAAOM,KAAKwB,EAAM,GAAK5B,EAAU6B,EAAM,GAAGC,EAAM,GAChDhC,EAAOM,KAAKwB,EAAM,GAAK5B,EAAU6B,EAAM,GAAGC,EAAM,GAChDhC,EAAOM,KAAKwB,EAAM,GAAK,SAKnCG,YAAYjC","sources":["scripts/game/floorCeil.worker.js"],"sourcesContent":["\n\nonmessage = function renderFloorCeil(e) {\n\n    let {player, buffer, strips, tileData,tileData2, tileSize,  h, w } = e.data;\n\n    buffer.forEach((e) => {\n        //if the current element has a 'sprite' key, its an object\n        if (e.sprite) {\n            return false; //render the object\n        } else {\n            //if not an object render the slice of wall\n            const distance = fixFishEye(e.distance, e.angle, player.angle);\n            const wallHeight = Math.floor((tileSize / distance) * player.projDist);\n            const xPos = e.sx;\n            const yPos = Math.floor(h / 2 - wallHeight / 2);\n\n            //----draw floor?----//\n            const Beta = Math.abs((e.angle - player.angle));\n            const yRow = yPos + wallHeight;\n\n            for (let row = yRow; row <= h; row++) {\n                const r = row - h / 2;\n                const sld = (player.z) / r * player.projDist;\n                const dist = sld / Math.cos(Beta);\n                let x = (player.x + Math.cos(e.angle) * dist)\n                let y = (player.y + Math.sin(e.angle) * dist);\n                x = x & (tileSize - 1);\n                y = y & (tileSize - 1);\n\n                //get teature positions\n                let inx = (((row) * w + xPos) * 4);\n                const tnx = (((x) * 32 + y) * 4);\n         \n                const shade = dist/4 ;\n                //floor\n                strips.data[inx] = tileData[tnx]-shade;\n                strips.data[inx + 1] = tileData[tnx + 1]-shade;\n                strips.data[inx + 2] = tileData[tnx + 2]-shade;\n                strips.data[inx + 3] = 255;\n                //ceilings\n                inx = (((h - row) * w + xPos) * 4);\n                strips.data[inx] = tileData2[tnx]-shade+25;\n                strips.data[inx + 1] = tileData2[tnx + 1]-shade+25;\n                strips.data[inx + 2] = tileData2[tnx + 2]-shade+25;\n                strips.data[inx + 3] = 255;\n            }\n        }\n\n    })\n    postMessage(strips);\n}\n\n\n\nfunction fixFishEye(distance, angle, playerAngle) {\n    const diff = angle - playerAngle;\n    return distance * Math.cos(diff);\n}"],"names":["onmessage","e","player","buffer","strips","tileData","tileData2","tileSize","h","w","data","forEach","sprite","distance","angle","playerAngle","diff","Math","cos","fixFishEye","wallHeight","floor","projDist","xPos","sx","yPos","Beta","abs","row","r","dist","x","y","sin","inx","tnx","shade","postMessage"],"sourceRoot":""}